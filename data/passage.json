{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1731152357468794881",
        "title": "MacBook电脑如何更高效的使用鼠标",
        "description": "MacBook电脑如何更高效的使用鼠标",
        "content": "作为一名使用两年多的mac用户已经十分依赖mac电脑开发带来的舒适感，在最开始刚换mac的时候就被它好用的触控板迷住了，以至于后面很长一段时间都没有使用鼠标，但是渐渐发现在我需要处理很多任务或者很忙的时候开了很多应用页面只使用触控板其实还是很痛苦的，比如你需要4个指头你滑动触控板去切换页面，切换的时间久了手指会被摩擦的很不舒服，尤其是在手特别干的时候，当天气热的时候又容易出汗，而且频繁的去切换自己手势虽然短时间内没什么，但是时间一长的话就感觉大脑有点麻木哈哈。\n\n经过很长时间的挣扎我还是决定使用鼠标，毕竟点一点手指就能完成的操作更丝滑不是吗？\n\n那么问题来了，我该如何用一个最普通的鼠标(也想过去买一个功能比较多的鼠标，但是总是有一种怪怪的感觉，所以还是放弃这个想法了)去完成伟大的妙控板可以完成的事呢？而且还不费力呢？\n\n思前想后只有一个办法，没错那就是手势，我们可以制定任何我们符合我们日常生活的手势去完成这些操作。\n\n想法有了，现在就差一款软件了（mac为了卖自己的鼠标当然不会这么便利，做的就是抵制资本哈哈），经过多款软件对比，最后终于找到了最合适mac的一款软件\n\n![image-20231203105249688](https://pic-es.oss-cn-shanghai.aliyuncs.com/study-pic/202312031052779.png)\n\n**WGestures**:一款可以让鼠标开挂的软件。\n\n![image-20231203105505935](https://pic-es.oss-cn-shanghai.aliyuncs.com/study-pic/202312031055956.png)\n\n可以根据自己的习惯去设定手势。比如我的：用鼠标右键向右滑=4个指头向右滑，向左滑=4个指头向左滑，右键画一个错号就是关闭当前页，以及最大化最小化看自己习惯去设置，我更多使用的是在开发工具里给一些复杂的快捷键去设定手势，比如设定debug的时候需要评估表达式，回退，前进等操作手势可以非常高效得提高生产效率。\n\n所以提高生产力有时候也可以从解放一只手做起，把操作都优化到一个指头上，是不是很优雅哈哈。",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1630821133601288193/6WM9aDMC-可爱002.jpg",
        "language": null,
        "viewNum": 2,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1630821133601288193",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-03T03:24:19.000+00:00",
        "updateTime": "2023-12-03T03:25:55.000+00:00",
        "user": {
          "id": "1630821133601288193",
          "planetCode": "9414",
          "userName": "小糖豆",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1630821133601288193/8ZwBYNWO-aaaa.jpg",
          "gender": 1,
          "userProfile": "一名刚毕业没多久的后端开发者，希望可以在这个圈子学到更多知识。",
          "userRole": "vip",
          "interests": [
            "后端",
            "书籍"
          ],
          "place": "北京",
          "birthday": "2000-12-16",
          "school": "",
          "major": "软件工程",
          "education": "一本",
          "graduationYear": 2023,
          "jobStatus": "已工作",
          "company": null,
          "job": "后端",
          "workYear": 1,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/hynzdc",
          "blog": "https://www.sweetmore.cn/",
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-06-04T14:02:41.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-03-01T06:43:52.000+00:00",
          "updateTime": "2023-11-29T07:30:37.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1730896476969758722",
        "title": "链表高频面试题",
        "description": "链表高频面试题",
        "content": "## 1 链表相交\n\n### 题目描述\n\n[面试题 02.07. 链表相交 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/)\n\n给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。\n\n图示两个链表在节点 `c1` 开始相交**：**\n\n[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)\n\n题目数据 **保证** 整个链式结构中不存在环。\n\n**注意**，函数返回结果后，链表必须 **保持其原始结构** 。\n\n**示例 1：**\n\n[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)\n\n```java\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n```\n\n\n\n### 解法一：哈希表\n\n```java\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB)\n{\n    HashSet<ListNode> hashSet = new HashSet<>();\n\n    while (headA != null)\n    {\n        hashSet.add(headA);\n        headA = headA.next;\n    }\n\n    while (headB != null)\n    {\n        if(hashSet.contains(headB))\n            return headB;\n\n        headB = headB.next;\n    }\n\n    return null;\n}\n```\n\n### 解法二：栈\n\n```java\npublic static ListNode getIntersectionNode(ListNode headA, ListNode headB)\n{\n    ArrayDeque<ListNode> stackA = new ArrayDeque<>();\n    ArrayDeque<ListNode> stackB = new ArrayDeque<>();\n\n    //两个链表分别入不同的栈\n    while (headA != null)\n    {\n        stackA.push(headA);\n        headA = headA.next;\n    }\n    while (headB != null)\n    {\n        stackB.push(headB);\n        headB = headB.next;\n    }\n\n\n    ListNode intersectionNode = null;   //要跟着两链表相同的结点\n\n    //从后往前理解（栈先进后出的特性）\n    while (!stackA.isEmpty() && !stackB.isEmpty())\n    {\n        if (stackA.peek().val == stackB.peek().val)\n        {\n            intersectionNode = stackA.pop();\n            stackB.pop();\n        }\n        else\n            break;  //两链表开始分叉，intersectionNode也指向了第一个交汇结点\n    }\n\n    return intersectionNode;\n```\n\n### 解法三：换表双指针\n\n```java\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB)\n{\n    //排除掉不好统一处理的空链表情况\n    if(headA == null || headB == null)\n        return null;\n\n    ListNode p = headA;\n    ListNode q = headB;\n\n    while(p != q)\n    {\n        p = p.next;\n        q = q.next;\n\n        if(p != q)\n        {\n            //自己的链表遍历完了就跳到另一个链表一直遍历下去，直到相遇，或者都等于null\n           if(p == null)\n               p = headB;\n           if(q == null)\n               q = headA;\n        }\n\n    }\n    //return得放在外面，否则编译报错：无返回语句\n    return p;\n}\n```\n\n### 解法四：差和双指针\n\n或称快慢指针。长链表的指针比短链表的指针先走|len1 - len2|步，然后同步移动，指向同一结点时返回答案\n\n```java\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB)\n{\n    if(headA == null || headB == null)\n        return null;\n\n    //获取headA的表长\n   ListNode p = headA;\n   int len_A = 0;\n   while (p != null)\n   {\n       len_A++;\n       p = p.next;\n   }\n\n    //获取headB的表长\n    ListNode q = headB;\n    int len_B = 0;\n    while (q != null)\n    {\n        len_B++;\n        q = q.next;\n    }\n\n    int diff = Math.abs(len_A - len_B);\n\n    if(len_A < len_B)   //headB先走\n    {\n        while (diff != 0)\n        {\n            headB = headB.next;\n            diff--;\n        }\n    }\n    else if(len_A > len_B)   //headA先走\n    {\n        while (diff != 0)\n        {\n            headA = headA.next;\n            diff--;\n        }\n    }\n\n    while (headA != headB)\n    {\n        headA = headA.next;\n        headB = headB.next;\n    }\n\n    return headA;\n}\n```\n\n\n\n## 2 回文链表\n\n### 题目描述\n\n[234. 回文链表 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-linked-list/description/)\n\n给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg)\n\n```java\n输入：head = [1,2,2,1]\n输出：true\n```\n\n\n\n### 解法一：值复制\n\n虽然这么做简单易懂，但面试手撕算法题时不推荐，因为会被视为逃避链表，失去了考验价值\n\n```java\n    public boolean isPalindrome(ListNode head) \n    {\n        //将每一个结点的值复制到ArrayList。\n        ArrayList<Integer> vals = new ArrayList<>();\n\n        while(head != null)\n        {\n            vals.add(head.val);\n            head = head.next;\n        }\n\n        //进行回文判断\n        int left = 0;\n        int right = vals.size() - 1;\n\n        while(left < right)\n        {\n            if(vals.get(left).equals(vals.get(right)) == false)\n                return false;\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n```\n\n\n\n### 解法二：快慢指针+反转链表\n\n```java\n//寻找中间结点。若链表有奇数个节点，则中间的节点应该看作是前半部分。\n    private ListNode endOfFirstHalf(ListNode head)\n    {\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast.next != null && fast.next.next != null)\n        {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n\n        return slow;\n    }\n\n    //反转链表\n    private ListNode reverseList(ListNode head)\n    {\n        ListNode pre = null;\n        ListNode suc = head;\n\n        while(head != null)\n        {\n            suc = head.next;\n            head.next = pre;     \n            pre = head;     \n            head = suc;     \n        }\n\n        return pre;\n    }\n\n    public boolean isPalindrome(ListNode head) \n    {\n        if(head == null)\n            return true;\n        \n        // 找到前半部分链表的尾节点并反转后半部分链表\n        ListNode firstHalfEnd = endOfFirstHalf(head);\n        ListNode secondHalfStart = reverseList(firstHalfEnd.next);\n\n        //判断是否是回文链表\n        ListNode p = head;\n        ListNode q = secondHalfStart;\n        boolean ans = true;\n        while(q != null)\n        {\n            if(p.val != q.val)\n            {\n                ans = false;\n                break;\n            }\n\n            p = p.next;\n            q = q.next;      \n        }\n\n        //恢复后半部分链表\n        firstHalfEnd.next = reverseList(secondHalfStart);\n\n        //返回判断结果\n        return ans;\n    }\n```\n\n\n\n### 解法三：栈\n\n```java\npublic static boolean isPalindrome(ListNode head)\n    {\n        ArrayDeque<ListNode> stack = new ArrayDeque<>();\n\n        ListNode t = head;\n        while (t != null)\n        {\n            stack.push(t);\n            t = t.next;\n        }\n\n        while (head != null)\n        {\n            if(stack.pop().val != head.val)\n                return false;\n            head = head.next;\n        }\n\n        return true;\n    }\n```\n\n\n\n## 3 合并链表\n\n### 3.1 合并两个有序链表\n\n#### 题目描述\n\n[21. 合并两个有序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-sorted-lists/description/)\n\n将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)\n\n```java\n输入：l1 = [1,2,4], l2 = [1,3,4]\n输出：[1,1,2,3,4,4]\n```\n\n\n\n#### 解\n\n```java\npublic ListNode mergeTwoLists(ListNode list1, ListNode list2) \n    {\n        if(list1 == null)\n            return list2;\n        if(list2 == null)\n            return list1;\n\n        ListNode p = list1; //新的引用\n        ListNode q = list2;\n        ListNode head = new ListNode(0 , null); //新链表的头结点\n        ListNode r = head;\n\n        while(p != null  && q != null)\n        {\n            //一次只处理一个结点\n            if(p.val <= q.val)  \n            {\n                r.next = p;\n                p = p.next;\n            }\n            else\n            {\n                r.next = q;\n                q = q.next;\n            }\n\n            r = r.next; //先链接，后更新\n        }\n\n        if(p == null)\n            r.next = q;\n        if(q == null)\n            r.next = p;\n\n        return head.next;\n    }\n```\n\n\n\n### 3.2 合并K个有序链表\n\n在3.1的基础上\n\n```java\npublic ListNode mergeKLists(ListNode[] lists) \n{\n\tListNode res = null;\n    //逐一链接\n\tfor (ListNode list: lists)\n\t\tres = mergeTwoLists(res,lists);\n\t\n    return res;\n}\n```\n\n\n\n### 3.3 嫁接两个链表\n\n#### 题目描述\n\n[1669. 合并两个链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-in-between-linked-lists/description/)\n\n给你两个链表 `list1` 和 `list2` ，它们包含的元素分别为 `n` 个和 `m` 个。\n\n请你将 `list1` 中下标从 `a` 到 `b` 的全部节点都删除，并将`list2` 接在被删除节点的位置。\n\n下图中蓝色边和节点展示了操作后的结果：\n\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/28/fig1.png)\n\n请你返回结果链表的头指针。\n\n**示例 1：**\n\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/28/merge_linked_list_ex1.png)\n\n```java\n输入：list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]\n输出：[0,1,2,1000000,1000001,1000002,5]\n解释：我们删除 list1 中下标为 3 和 4 的两个节点，并将 list2 接在该位置。上图中蓝色的边和节点为答案链表。\n```\n\n\n\n#### 解\n\n```java\npublic ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {\n    ListNode pre = list1;\n    ListNode post = list1;\n    int i = 0;\n    int j = 0;\n\n    //定位待删除部分的前驱和后继\n    while (i < a - 1) { //用<号，i=a-2时最后一次进入循环，退出循环时pre刚好指向下标为a-1的结点\n        pre = pre.next;\n        i++;\n    }\n\n    while (j < b + 1) {\n        post = post.next;\n        j++;\n    }\n\n    //定位list2的尾结点\n    ListNode r = list2;\n    while (r.next != null)\n        r = r.next;\n\n    //连接\n    pre.next = list2;\n    r.next = post;\n\n    return list1;\n}\n```\n\n\n\n## 4 双指针专题\n\n### 4.1 寻找中间结点\n\n#### 题目描述\n\n[876. 链表的中间结点 - 力扣（LeetCode）](https://leetcode.cn/problems/middle-of-the-linked-list/description/)\n\n给你单链表的头结点 `head` ，请你找出并返回链表的中间结点。\n\n如果有两个中间结点，则返回第二个中间结点。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg)\n\n```java\n输入：head = [1,2,3,4,5]\n输出：[3,4,5]\n解释：链表只有一个中间结点，值为 3 。\n```\n\n\n\n#### 解\n\n```java\n    public ListNode middleNode(ListNode head)\n    {\n        ListNode p = head;\n        ListNode q = head;\n\n    \t//p每次走两步，q每次走一步\n    \t//p走到最后的NULL时,q恰好到中间\n    \t//偶数个结点的话，q则指向第二个中间结点\n    \twhile(p !=null && p.next != null)\n    \t{\n        \tp = p.next.next;\n        \tq = q.next;\n    \t} \n\n    \treturn q;\n    }\n```\n\n\n\n### 4.2 寻找倒数第K个元素\n\n#### 解法一：两次遍历\n\n第一次遍历得到链表长度，第二次遍历找倒数K个元素\n\n#### 解法二：快慢指针\n\n两种模板\n\n```java\npublic ListNode getNthFromEnd(ListNode head, int n)\n{\n    ListNode fast = head;\n    ListNode slow = head;\n\n    while (fast != null)\n        {\n            if(n <= 0)   \n            \tslow = slow.next; \n            \n        \tfast = fast.next;\n        \tn--;\n        }\n    \n    return slow;\n}\n```\n\n```java\npublic ListNode getKthFromEnd(ListNode head, int k)\n    {\n    ListNode fast = head;\n    ListNode slow = head;\n\n    while(fast != null && k > 0)\n    {\n        fast = fast.next;\n        k--;\n    }\n    \n    while(fast != null)\n    {\n        fast = fast.next;\n        slow = slow.next; \n    }\n    \n    return slow;\n}\n```\n\n\n\n### 4.3 旋转链表\n\n#### 题目描述\n\n[61. 旋转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/rotate-list/description/)\n\n给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg)\n\n```java\n输入：head = [1,2,3,4,5], k = 2\n输出：[4,5,1,2,3]\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg)\n\n```java\n输入：head = [0,1,2], k = 4\n输出：[2,0,1]\n```\n\n\n\n#### 解\n\n```java\npublic ListNode rotateRight(ListNode head, int k)\n{\n    if (head == null || k == 0)\n        return head;\n\n    //获取链表长度\n    ListNode t = head;\n    int length = 0;\n    while (t != null)\n    {\n        length++;\n        t = t.next;\n    }\n\n    int K = k % length; //最小旋转次数\n    if(K == 0)\n        return head;\n    //寻找倒数第K个结点的前驱\n    ListNode fast = head;\n    ListNode slow = head;   //倒数第K个结点的前驱\n    while (fast.next != null)   //fast需要停留在最后一个结点\n    {\n        if(K <= 0)\n            slow = slow.next;\n\n        fast = fast.next;\n        K--;\n    }\n\n    ListNode res = slow.next;   //旋转过后的链表的头结点为倒数第K个结点\n    slow.next = null;  //断开前驱与倒数第K个结点的链接，避免成环。即slow作为新链表的尾结点\n    fast.next = head;   //原尾结点连接原头结点，\"旋转\"完成\n\n    return res;\n}\n```\n\n\n\n## 5 删除链表元素\n\n### 5.1 删除特点结点\n\n#### 题目描述\n\n[203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/description/)\n\n给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg)\n\n```java\n输入：head = [1,2,6,3,4,5,6], val = 6\n输出：[1,2,3,4,5]\n```\n\n\n\n#### 解法一：单独处理头结点\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution \n{\n    public ListNode removeElements(ListNode head, int val) \n    {\n        //val出现在头结点\n        while(head != null && head.val == val)  \n            head = head.next;\n    \n         if(head == null)\n            return head;  //直接解决全部都是val的情况\n\n\n    ListNode p = head;\n\n    while(p != null && p.next != null)  //常规情况\n    {\n        if(p.next.val == val)\n        {\n            p.next = p.next.next;  \n        }\n        else\n        {\n            p = p.next;\n        }\n    }\n\n    return head;\n    }\n}\n```\n\n\n\n#### 解法二：虚拟结点\n\n```java\npublic ListNode removeElements(ListNode head, int val)\n{\n    ListNode dummyNode = new ListNode(-1);\n    dummyNode.next = head;  //为将头结点当作普通结点处理\n    ListNode cur = dummyNode;\n\n    while (cur.next != null)    //如果尾结点也是要删除的结点，那它也能被“跳过”。要时刻谨记.next存的是下一结点的地址，不是一根线\n    {\n        if(cur.next.val == val)\n            cur.next = cur.next.next;   //cur所指结点的后继变了，且cur仍然指向当前结点\n        else\n            cur = cur.next; //下一个结点的值（终于）不重复时，cur才指向下一个结点\n    }\n\n    return dummyNode.next;\n}\n```\n\n\n\n### 5.2 删除倒数第n个结点\n\n#### 题目描述\n\n[19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)\n\n给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)\n\n```java\n输入：head = [1,2,3,4,5], n = 2\n输出：[1,2,3,5]\n```\n\n\n\n#### 解法一：两次遍历\n\n```c\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n)\n{\n    //计算链表长度\n    struct ListNode* fast = head;\n    struct ListNode* slow = head;\n\n    while(fast)\n    {\n        if(n < 0)\n            slow = slow->next; //慢指针开始与快指针同步移动\n        fast = fast->next;\n        n--;\n    }\n\n    if(n == 0)  //要删除的是头结点，返回其余结点\n        return head->next;\n\n    slow->next = slow ->next->next; //删除指定结点\n\n    return head;      \n}\n\n```\n\n\n\n#### 解法二：快慢指针一次遍历\n\n```java\npublic ListNode removeNthFromEnd(ListNode head, int n)\n    {\n         //计算链表长度\n    \tListNode fast = head;\n    \tListNode slow = head;\n\n    \twhile(fast != null)\n    \t{\n        \tif(n < 0)\t//慢指针开始与快指针同步移动，最终slow会指向待删除结点的前驱\n            \tslow = slow.next; \n        \tfast = fast.next;\n        \tn--;\n    \t}\n\n    \tif(n == 0)  //若删除的是头结点，则返回其余结点\n        \treturn head.next;\n\n    \tslow.next = slow.next.next; //删除指定结点\n\n    \treturn head; \n    }\n```\n\n\n\n### 5.3 重复元素保留一个\n\n#### 题目描述\n\n[83. 删除排序链表中的重复元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/)\n\n给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/01/04/list1.jpg)\n\n```java\n输入：head = [1,1,2]\n输出：[1,2]\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/01/04/list2.jpg)\n\n```java\n输入：head = [1,1,2,3,3]\n输出：[1,2,3]\n```\n\n\n\n#### 解\n\n```java\npublic ListNode deleteDuplicates(ListNode head)\n{\n    if (head == null)\n        return null;\n\n    ListNode cur = head;\n\n    while (cur.next != null)\n    {\n        if(cur.val == cur.next.val)\n            cur.next = cur.next.next;\n        else\n            cur = cur.next;\n    }\n\n    return head;\n}\n```\n\n\n\n### 5.4 重复元素一个都不要\n\n#### 题目描述\n\n[82. 删除排序链表中的重复元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/)\n\n给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg)\n\n```java\n输入：head = [1,2,3,3,4,4,5]\n输出：[1,2,5]\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg)\n\n```java\n输入：head = [1,1,1,2,3]\n输出：[2,3]\n```\n\n\n\n#### 解\n\n```java\npublic ListNode deleteDuplicates(ListNode head)\n{\n    ListNode dummyNode = new ListNode(0, head);\n    ListNode cur = dummyNode;\n\n    while (cur.next != null && cur.next.next != null)\n    {\n        if (cur.next.val == cur.next.next.val)\n        {\n            //用一个小循环删除这部分重复元素\n            int x = cur.next.val;\n            while (cur.next != null && cur.next.val == x)\n            {\n                cur.next = cur.next.next;   //把指针域也画出来才容易理解\n            }\n        }\n        else    //如if被执行，则cur不会往后移动，这使得两个while可以合力一口气删完如[2,2,3,3,5,5,5]的重复部分，然后cur才需要往后移动\n            cur = cur.next;\n    }\n\n    return dummyNode.next;\n}\n```",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1703618142791659522/Ysz19b47-dian ni.jpg",
        "language": null,
        "viewNum": 1,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1703618142791659522",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-02T10:27:33.000+00:00",
        "updateTime": "2023-12-02T10:27:39.000+00:00",
        "user": {
          "id": "1703618142791659522",
          "planetCode": "27324",
          "userName": "陈星泽",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1703618142791659522/5K8Myn4Z-1684984658778.jpg",
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-09-18T03:36:38.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-09-18T03:53:11.000+00:00",
          "updateTime": "2023-09-21T04:58:45.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1730780800867233794",
        "title": "session与token的区别",
        "description": null,
        "content": "1. session存放在服务器端，token存放在客户端。\n2. token提供认证和授权功能，对于身份认证，token的安全性要比session好很多。\n3. session适用于非前后端分离项目，token适用于前后端分离项目。",
        "category": "面试题",
        "cover": null,
        "language": null,
        "viewNum": 4,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1608812742599245826",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-02T02:47:53.000+00:00",
        "updateTime": "2023-12-02T11:54:04.000+00:00",
        "user": {
          "id": "1608812742599245826",
          "planetCode": "5185",
          "userName": "葛成",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/sqZ24tHwumJ8fHiabmZOqemicECaic6INZmtXAOzf6lXq4P7NaPwiaCLW29O7cc3v1JGibnMuse3mJcVNCtnw4LBwrQ/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 1,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-04-22T04:22:23.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-30T13:10:22.000+00:00",
          "updateTime": "2023-11-30T08:20:35.000+00:00"
        },
        "tags": [
          "面试题"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1730775008147533825",
        "title": "Get请求和Post请求的区别",
        "description": null,
        "content": "1. Get请求的请求参数是通过url传递，Post请求的参数是存放在请求体中。\n2. Get请求在url中传递的参数是有长度限制的，而Post没有长度限制。\n3. Get请求只能通过url编码，而Post支持多种编码方式。\n4. Get请求参数会被完整保留在浏览历史请求中，而Post请求中的参数不会被保留。",
        "category": "面试题",
        "cover": null,
        "language": null,
        "viewNum": 3,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1608812742599245826",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-02T02:24:52.000+00:00",
        "updateTime": "2023-12-02T07:24:22.000+00:00",
        "user": {
          "id": "1608812742599245826",
          "planetCode": "5185",
          "userName": "葛成",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/sqZ24tHwumJ8fHiabmZOqemicECaic6INZmtXAOzf6lXq4P7NaPwiaCLW29O7cc3v1JGibnMuse3mJcVNCtnw4LBwrQ/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 1,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-04-22T04:22:23.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-30T13:10:22.000+00:00",
          "updateTime": "2023-11-30T08:20:35.000+00:00"
        },
        "tags": [
          "面试题",
          "Java",
          "后端"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1730582996127444993",
        "title": "大三-后端实习-寒假实习",
        "description": "https://laoyujianli.com/i_share/JDlqx5",
        "content": "<p>想找个寒假实习，这份简历还有没有优化的地方</p>",
        "category": "简历",
        "cover": null,
        "language": null,
        "viewNum": 21,
        "thumbNum": 0,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1627519153885716481",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-01T13:41:53.000+00:00",
        "updateTime": "2023-12-03T02:28:10.000+00:00",
        "user": {
          "id": "1627519153885716481",
          "planetCode": "2592",
          "userName": "无名",
          "userAvatar": null,
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-02-24T08:25:00.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-02-20T04:02:58.000+00:00",
          "updateTime": "2023-11-21T14:45:02.000+00:00"
        },
        "tags": [
          "简历"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1730436983710412802",
        "title": "ArrayList和LinkedList的区别",
        "description": null,
        "content": "1. 底层数据结构：ArrayList的底层数据结构是一个Object数组，LinkedList的底层数据结构是一个双向循环链表。\n2. 查找效率：ArrayList的在随机查找方面比LinkedList效率要高，ArrayList实现了RandomAccess接口，因此查找的时候非常快。而LinkedList是线性的存储方式，需要移动指针从前往后查找。\n3. 插入和删除效率：在非首尾的插入和修改操作，LinkedList的效率比ArrayList要高，因为ArrayList增删操作会影响到数组中其他元素的下标。\n4. 适用范围：ArrayList适用于频繁查找集合中元素的场景，而LinedList适用于经常插入和删除元素的场景。",
        "category": "面试题",
        "cover": null,
        "language": null,
        "viewNum": 15,
        "thumbNum": 0,
        "favourNum": 1,
        "commentNum": 1,
        "priority": 0,
        "userId": "1608812742599245826",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-12-01T04:01:41.000+00:00",
        "updateTime": "2023-12-02T10:09:35.000+00:00",
        "user": {
          "id": "1608812742599245826",
          "planetCode": "5185",
          "userName": "葛成",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/sqZ24tHwumJ8fHiabmZOqemicECaic6INZmtXAOzf6lXq4P7NaPwiaCLW29O7cc3v1JGibnMuse3mJcVNCtnw4LBwrQ/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 1,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-04-22T04:22:23.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-30T13:10:22.000+00:00",
          "updateTime": "2023-11-30T08:20:35.000+00:00"
        },
        "tags": [
          "面试题",
          "后端",
          "Java"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1730148626065387521",
        "title": "Mybatis整合多数据源",
        "description": "有时候我们需要查询来自多个库表的数据内容，但是又不想起多个服务，可以业务需要这些数据那该怎么办呢？那么其实Mybatis 是支持整合多数据源，并随时进行切换。",
        "content": "## 背景\n\n有时候我们需要查询来自多个库表的数据内容，但是又不想起多个服务，可以业务需要这些数据那该怎么办呢？那么其实Mybatis 是支持整合多数据源，并随时进行切换。\n\n## 解决\n\n### 引入依赖\n\n首先引入`dynamic-datasource-spring-boot-starter`依赖\n\n```xml\n<dependency>\n  <groupId>com.baomidou</groupId>\n  <artifactId>dynamic-datasource-spring-boot-starter</artifactId>\n  <version>${version}</version><!--版本号-->\n</dependency>\n```\n\n### 配置文件\n\n```yaml\nmybatis-plus:\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n    map-underscore-to-camel-case: true\n  mapper-locations: mapper/*.xml\n\nserver:\n  port: 8989\n\nspring:\n  datasource:\n    dynamic:\n      primary: master\n      strict: false\n      datasource:\n        master:\n          url: jdbc:mysql://localhost:3306/yuapi?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&useSSL=false\n          username: root\n          password: root\n          driver-class-name: com.mysql.cj.jdbc.Driver\n        slave_1:\n          url: jdbc:mysql://localhost:3306/db_email?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&useSSL=false\n          username: root\n          password: root\n          driver-class-name: com.mysql.cj.jdbc.Driver\n```\n\n#### 配置方式\n\n```yaml\n# 多主多从                      纯粹多库（记得设置primary）                   混合配置\nspring:                               spring:                               spring:\n  datasource:                           datasource:                           datasource:\n    dynamic:                              dynamic:                              dynamic:\n      datasource:                           datasource:                           datasource:\n        master_1:                             mysql:                                master:\n        master_2:                             oracle:                               slave_1:\n        slave_1:                              sqlserver:                            slave_2:\n        slave_2:                              postgresql:                           oracle_1:\n        slave_3:                              h2:                                   oracle_2:\n\n```\n\n\n\n### 通过注解切换数据源\n\n可以通过`@DS`注解进行数据源切换\n\n```java\n@Service\n@DS(\"master\")\npublic class InterfaceInfoServiceImpl extends ServiceImpl<InterfaceInfoMapper, InterfaceInfo> implements InterfaceInfoService {\n}\n```\n\n```java\n@Service\n@DS(\"slave_1\")\npublic class TEmailServiceImpl extends ServiceImpl<TEmailMapper, TEmail> implements TEmailService {\n}\n```\n\n注解的内容对应配置里的名称。\n\n## 约定\n\n1. 本框架只做 切换数据源 这件核心的事情，并不限制你的具体操作，切换了数据源可以做任何CRUD。\n2. 配置文件所有以下划线 _ 分割的数据源 首部 即为组的名称，相同组名称的数据源会放在一个组下。\n3. 切换数据源可以是组名，也可以是具体数据源名称。组名则切换时采用负载均衡算法切换。\n4. .默认的数据源名称为 master ，你可以通过 spring.datasource.dynamic.primary 修改。\n5. 方法上的注解优先于类上注解。\n6. DS支持继承抽象类上的DS，暂不支持继承接口上的DS，在方法上面标记优先级高于在类上标记。\n\n> 注意这个原理也是基于AOP,所以在一个方法内是不可以切换数据源的。",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1630821133601288193/dmzjP4Xn-可爱001.jpg",
        "language": null,
        "viewNum": 16,
        "thumbNum": 4,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1630821133601288193",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-11-30T08:55:51.000+00:00",
        "updateTime": "2023-12-02T08:03:14.000+00:00",
        "user": {
          "id": "1630821133601288193",
          "planetCode": "9414",
          "userName": "小糖豆",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1630821133601288193/8ZwBYNWO-aaaa.jpg",
          "gender": 1,
          "userProfile": "一名刚毕业没多久的后端开发者，希望可以在这个圈子学到更多知识。",
          "userRole": "vip",
          "interests": [
            "后端",
            "书籍"
          ],
          "place": "北京",
          "birthday": "2000-12-16",
          "school": "",
          "major": "软件工程",
          "education": "一本",
          "graduationYear": 2023,
          "jobStatus": "已工作",
          "company": null,
          "job": "后端",
          "workYear": 1,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/hynzdc",
          "blog": "https://www.sweetmore.cn/",
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-06-04T14:02:41.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-03-01T06:43:52.000+00:00",
          "updateTime": "2023-11-29T07:30:37.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1730046686493011969",
        "title": "什么是跨平台？实现原理是什么",
        "description": null,
        "content": "跨平台：Java语言编写的程序，一次编译之后，可以运行在多个操作系统平台上。\n实现原理：Java程序是通过JVM在操作系统平台上运行的，只要该系统安装相应的JVM就可以运行Java程序。",
        "category": "面试题",
        "cover": null,
        "language": null,
        "viewNum": 8,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1608812742599245826",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-11-30T02:10:47.000+00:00",
        "updateTime": "2023-12-01T07:07:19.000+00:00",
        "user": {
          "id": "1608812742599245826",
          "planetCode": "5185",
          "userName": "葛成",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/sqZ24tHwumJ8fHiabmZOqemicECaic6INZmtXAOzf6lXq4P7NaPwiaCLW29O7cc3v1JGibnMuse3mJcVNCtnw4LBwrQ/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 1,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-04-22T04:22:23.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-30T13:10:22.000+00:00",
          "updateTime": "2023-11-30T08:20:35.000+00:00"
        },
        "tags": [
          "面试题",
          "Java",
          "后端"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1730019669194174466",
        "title": "SQL还能这么写？",
        "description": "十种SQL的语法",
        "content": "## SQL语法\n\n### 一、ORDER BY FIELD()自定义排序逻辑\n\nORDER BY FIELD(str,str1,...) 自定义排序sql如下：\n\n```sql\nSELECT * from order_diy ORDER BY FIELD(title,'九阴真经', '降龙十八掌','九阴白骨爪','双手互博','桃花岛主','全真内功心法','蛤蟆功','销魂掌','灵白山少主');\n```\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/4TzuXuKG-image.png)\n\n\n\n### 二、CASE表达式\n\n假如我们想在 order_diy 表加一列 level 列，根据money 判断大于60就是高级，大于30就是中级，其余显示低级，sql 如下：\n\n```sql\nSELECT *, \ncase when money > 60 then '高级' \nwhen money > 30 then '中级' \nelse '低级' END level \nfrom order_diy;\n```\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/QPBUIM5h-image.png)\n\n\n### 三、EXISTS用法\n\n可知 exists 后面是跟着一个子查询语句，它的作用是**根据主查询的数据，每一行都放到子查询中做条件验证，根据验证结果（TRUE 或者 FALSE），TRUE的话该行数据就会保留**，下面用 emp 表和 dept 表进行举例，表结构以及数据展示：计入我们现在想找到 emp 表中 dept_name 与 dept表 中 dept_name 对应不上员工数据，sql 如下：\n\n```sql\nSELECT * from emp e where exists (\nSELECT * from dept p where e.dept_id = p.dept_id \nand e.dept_name != p.dept_name\n)\n```\n\n### 四、GROUP CONCAT(expr)组连接函数\n\n**GROUP_CONCAT(expr)** 组连接函数可以返回分组后指定字段的字符串连接形式，并且可以指定排序逻辑，以及连接字符串，默认为英文逗号连接。这里继续用 order_diy 表举例：sql 如下：\n\n```sql\nSELECT name, GROUP_CONCAT(title ORDER BY id desc  SEPARATOR '-') \nfrom order_diy GROUP BY name ORDER BY NULL;\n```\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/M8jS3B8Y-image.png)\n\n\n### 五、自连接查询\n\ntree 表中通过 pid 字段与 id 字段进行父子关联，假如现在有一个需求，我们想按照父子层级将 tree 表数据转换成 `一级职位 二级职位 三级职位` 三个列名进行展示，sql 如下：\n\n```sql\nSELECT t1.job_name '一级职位', t2.job_name '二级职位', t3.job_name '三级职位' \nfrom tree t1 join tree t2 on t1.id = t2.pid left join tree t3 on t2.id = t3.pid \nwhere t1.pid = 0;\n```\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/YWtSAL7p-image.png)\n\n\n### 六、更新emp表和dept表关联数据\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/s0HuySGC-image.png)\n\n可以看到上述 emp 表中 jack 的部门名称与 dept 表实际不符合，现在我们想将 jack 的部门名称更新成 dept 表的正确数据，sql 如下：\n\n```sql\nupdate emp, dept set emp.dept_name = dept.dept_name\nwhere emp.dept_id = dept.dept_id;\n```\n\n### 七、ORDER BY空值NULL排序\n\nORDER BY 字句中可以跟我们要排序的字段名称，但是当字段中存在 null 值时，会对我们的排序结果造成影响。我们可以通过 **ORDER BY IF(ISNULL(title), 1, 0)** 语法将 null 值转换成0或1，来达到将 null 值放到前面还是后面进行排序的效果。这里继续用 order_diy 表举例，sql 如下：\n\n```sql\nSELECT * FROM order_diy ORDER BY  IF(ISNULL(title), 0, 1), money;\n```\n\n### 八、with rollup分组统计数据的基础上再进行统计汇总\n\nMySql 中可以使用 with rollup 在分组统计数据的基础上再进行统计汇总，即用来得到 group by 的汇总信息。这里继续用order_diy 表举例，sql 如下：\n\n```sql\nSELECT name, SUM(money) as money \nFROM order_diy GROUP BY name WITH ROLLUP;\n复制代码\n```\n\n查询结果：\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/QlZ1AXen-image.png)\n\n\n可以看到通过 **GROUP BY name WITH ROLLUP** 语句，查询结果最后一列显示了分组统计的汇总结果。但是 name 字段最后显示为 null，我们可以通过 `coalesce(val1, val2, ...)` 函数，这个函数会返回参数列表中的第一个非空参数。\n\n### 九、with as 提取临时表别名\n\n如果一整句查询中**多个子查询都需要使用同一个子查询**的结果，那么就可以用 with as，将共用的子查询提取出来，加个别名。后面查询语句可以直接用，对于大量复杂的SQL语句起到了很好的优化作用。这里继续用 order_diy 表举例，这里使用 with as 给出 sql 如下：\n\n```sql\n-- 使用 with as\nwith t1 as (SELECT * from order_diy where money > 30),\nt2 as (SELECT * from order_diy where money > 60)\nSELECT * from t1 \nwhere t1.id not in (SELECT id from  t2) and t1.name = '周伯通';\n```\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/Ch4NIUhN-image.png)\n\n### 十、存在就更新，不存在就插入\n\nMySql 中通过**on duplicate key update**语法来实现存在就更新，不存在就插入的逻辑。插入或者更新时，它会根据表中主键索引或者唯一索引进行判断，如果主键索引或者唯一索引有冲突，就会执行**on duplicate key update**后面的赋值语句。 这里通过 news 表举例，表结构和说数据展示，其中 news_code 字段有唯一索引：\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/Bcu6T57I-image.png)\n 添加sql：\n\n```sql\n-- 第一次执行添加语句\nINSERT INTO `news` (`news_title`, `news_auth`, `news_code`) \nVALUES ('新闻3', '小花', 'wx-0003') \non duplicate key update news_title = '新闻3';\n-- 第二次执行修改语句\nINSERT INTO `news` (`news_title`, `news_auth`, `news_code`) \nVALUES ('新闻4', '小花', 'wx-0003') \non duplicate key update news_title = '新闻4';\n```",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 16,
        "thumbNum": 1,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1612254411675926529",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-11-30T00:23:25.000+00:00",
        "updateTime": "2023-12-02T07:17:50.000+00:00",
        "user": {
          "id": "1612254411675926529",
          "planetCode": "12852",
          "userName": "聪ζ",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1612254411675926529/JbN5T832-1.jpg",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": "本科",
          "graduationYear": 2023,
          "jobStatus": "已工作",
          "company": null,
          "job": "后端",
          "workYear": null,
          "direction": "后端",
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-02-09T22:01:57.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-09T01:06:20.000+00:00",
          "updateTime": "2023-10-30T12:03:51.000+00:00"
        },
        "tags": [
          "文章",
          "MySQL"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1729868762959704065",
        "title": "foreach循环中remove操作 （什么是fail-fast）",
        "description": "Java中有个fail-fast错误检测机制，一旦检测到可能发生错误，就会立马抛出异常，程序不能继续执行下去。",
        "content": "先来看看下面的三段代码，你觉得有哪几个会报错，那几个会正确输出list\n\n```java\nList<String> list = new ArrayList<>();\n        list.add(\"2\");\n        list.add(\"2\");\n        for(String str:list){\n            if(\"2\".equals(str)){\n                list.remove(str);\n            }\n        }\n        System.out.println(list);\n```\n\n```java\nList<String> list = new ArrayList<>();\n        list.add(\"2\");\n        list.add(\"2\");\n        list.add(\"3\");\n        for(String str:list){\n            if(\"2\".equals(str)){\n                list.remove(str);\n            }\n        }\n        System.out.println(list);\n```\n\n```java\nList<String> list = new ArrayList<>();\n        list.add(\"1\");\n        list.add(\"2\");\n        list.add(\"3\");\n        for(String str:list){\n            if(\"2\".equals(str)){\n                list.remove(str);\n            }\n        }\n        System.out.println(list);\n    }\n```\n先公布答案\n上面上段代码执行结果分别是：\n```[2]```\n```Exception in thread \"main\" java.util.ConcurrentModificationException\n\tat java.util.ArrayList$Itr.checkForComodification(ArrayList.java:911)\n\tat java.util.ArrayList$Itr.next(ArrayList.java:861)\n\tat com.xmz.test.Test.main(Test.java:16)\n```\n```[1, 3]```\n\n## 先说正确规范\n在阿里巴巴手册中明确规定了，不要在foreach中使用```remove\\add```操作。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d02443d2c2e7431b902327d49e29b4d6.png)\n## 【问题】为什么上面代码1，3没问题？2会抛异常\n**异常的原因**：\n\t因为增强for循环是根据迭代器遍历的，在循环中修改集合大小，会导致迭代器中的数据不一致，可能导致错误。\n\tJava中有个fail-fast错误检测机制，一旦检测到可能发生错误，就会立马抛出异常，程序不能继续执行下去。\n**1和3为什么不报异常？**\n\t因为在某些特殊情况下，```list.remove(str)```可以在不触发```fail-fast```机制的情况下删除元素。\n\t例如在上面的第一、三两个代码中，我们删除的是列表中的倒数第二个元素，那么就不会抛出异常，因为这种情况下，删除了元素，同时也改变了列表的大小，使得列表的大小和当前的cursor的大小一样，因此就不会执行```checkForComodification()```方法，也就不会抛出异常。\n\n## 【方案】怎么在集合中正确使用```remove\\add```操作\n### 方案一、使用普通for循环进行操作\n```java\n List<String> list = new ArrayList<>();\n        list.add(\"2\");\n        list.add(\"2\");\n        list.add(\"3\");\n        for (int i = 0; i < list.size(); i++) {\n            if(\"2\".equals(list.get(i))){\n                list.remove(list.get(i));\n            }\n        }\n        System.out.println(list);\n```\n但是这种方案在remove的时候，会存在漏删的情况。\n输出结果：```[2, 3]```\n\n### 方案二、使用Iterator提供的remove方法。\n这也就是在阿里巴巴开发手册中的方法\n```java\nList<String> list = new ArrayList<>();\n        list.add(\"2\");\n        list.add(\"2\");\n        list.add(\"3\");\n        Iterator<String> iterator = list.iterator();\n        while (iterator.hasNext()){\n            String str = iterator.next();\n            if(\"2\".equals(str)){\n                iterator.remove();\n            }\n        }\n        System.out.println(list);\n```\n输出结果：```[3]```\n这是最正确的方案\n\n### 方案三、使用filter过滤\n```java\nList<String> list = new ArrayList<>();\n        list.add(\"2\");\n        list.add(\"2\");\n        list.add(\"3\");\n        list = list.stream().filter(str -> !\"2\".equals(str)).collect(Collectors.toList());\n        System.out.println(list);\n```\n输出结果：```[3]```\n\n### 方案四、使用增强for循环也可以，但是每次要break\n如果这个集合中只有一个我们要删除的元素，就可以使用这种方案，像set集合，如果list集合里面有多个要删除的元素，最终只能成功删除第一个\n```java\nList<String> list = new ArrayList<>();\n        list.add(\"1\");\n        list.add(\"2\");\n        list.add(\"3\");\n        for(String str:list){\n            if(\"1\".equals(str)){\n                list.remove(str);\n                break;\n            }\n        }\n        System.out.println(list);\n```\n输出结果：```[2, 3]```\n\n### 方案五、使用fail-fast集合类\n在Java中，有一些fail-fast机制的集合类。这样的集合容器在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。\n由于在迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能背迭代器检测到。\n\n```java\n        ConcurrentLinkedDeque<String> concurrentLinkedDeque = new ConcurrentLinkedDeque<>();\n        concurrentLinkedDeque.add(\"2\");\n        concurrentLinkedDeque.add(\"2\");\n        concurrentLinkedDeque.add(\"3\");\n        for(String str:concurrentLinkedDeque){\n            if(\"2\".equals(str)){\n                concurrentLinkedDeque.remove(str);\n            }\n        }\n        System.out.println(concurrentLinkedDeque);\n```\n\n### 参考文章\n[参考文章：什么是fail-fast](https://www.cnblogs.com/54chensongxia/p/12470446.html)",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 7,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1627708957655060481",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-11-29T14:23:47.000+00:00",
        "updateTime": "2023-12-02T12:25:48.000+00:00",
        "user": {
          "id": "1627708957655060481",
          "planetCode": "2020",
          "userName": "onepiece",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1627708957655060481/LJ6EWTRq-595942610193259787.jpg",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-02-21T22:31:28.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-02-20T16:37:11.000+00:00",
          "updateTime": "2023-08-08T13:27:58.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "后端"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "7158",
    "size": "10",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "716"
  },
  "message": "ok"
}